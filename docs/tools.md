# Инструменты
Большую часть действий с инструментами ведруины и скриптами в `tools/` можно проводить через
`make`.

Для этого в конфигурации должны быть заданы параметры секции `tools`.

Цели для `make`:
* `conf` - сгенерировать `src/conf.h` из конфигурационного файла `CONF` (по умолчанию `CONF=./config.ini`).
* `clean` - удалить последний собранный образ прошивки.
* `cleanall` - удалить всю папку `build/` и `src/conf.h`.
* `setup` - настроить `arduino-cli` (первое, что нужно выполнить после клонирования).
* `build` - выполнить `conf` (если надо), затем собрать `.bin` и `.elf` файлы.
* `updcc` - обновить `compile_commands.json` (или создать, если его еще нет).
* `flash` - выполнить `build` (если надо) и прошить.
* `mon` - запустить монитор последовательного порта с обработкой бектрейсов.
* `netlog` - запустить клиент [netlog](./netlog.md) с обработкой бектрейсов.
* `ota` - выполнить обновление через TCP [ota](./ota.md).
* `disasm` - дизассемблировать прошивку в `/tmp/{sketch_name}.s` (бывает полезным для отладки).
* `all` - `build`, `flash` и `mon`

В папку `build/` сохраняются `.bin`, `.elf` и всякое для ведруины.
В репозиторий она не попадает.

## Конфигурация
```ini
[lib.tools]
sketch_name=vedruino
fqbn=esp32:esp32:esp32da
xtensa_toolchain_path=~/.arduino15/packages/esp32/tools/xtensa-esp32-elf-gcc/...
serial_port=/dev/ttyUSB0
board_hostname=HOSTNAME.local
serial_flags=
netlog_flags=
```

* `sketch_name` - должно совпадать с названием репозитория и `.ino` файла в нём.
* `fqbn` - FQBN платы.
* `xtensa_toolchain_path` - путь к папке с исполняемыми файлами тулчейна gcc для esp32 xtensa,
  их можно найти в папке esp32 для ведруины.
* `serial_port` - путь к последовательному порту, обязательно для `flash` и `mon`.
* `board_hostname` - IP адрес платы или её hostname (если на ней работает [mDNS](./mdns.md)), 
  обязательно для `ota` и `netlog`.
* `mon_flags` - флаги для цели `mon` (передаются в `tools/mon.py`).
* `netlog_flags` - флаги для цели `netlog` (передаются в `tools/netlog.py`).

## Просмотр логов с платы
Либо через `mon`, либо `netlog`.

Первый занимает последовательный порт, поэтому больше одного запустить не получится, а если надо
записать прошивку через провод, то его надо выключить. Не мешает проводить OTA.

Второй может работать с несколькими подключениями, не мешает записи прошивки ни через провод,
ни через OTA.

## Бектрейсы
Для обработки бектрейсов использовать `tools/btrace.py` (`make mon` и `netlog` его используют автоматически).

Этот скрипт считывает каждую строку из stdin и выводит в stdout, изменяя вид бектрейсов: к адресам
добавляются названия файлов, номера строк в них и названия функций. Цвет текста меняется на фиолетовый.

Бектрейсы ESP выглядят так (не могут передаваться через `netlog`):
```
ESP backtrace {
 - 0x400d494c:0x3ffb2260
   /home/user/vedruino/src/main.cpp:56
   setup()
 - 0x400d505e:0x3ffb2290
   /home/user/.arduino15/packages/esp32/hardware/esp32/2.0.14/cores/esp32/main.cpp:42
   loopTask(void*)
}
```

Бектрейсы от ЕSP выводятся вызовом `esp_backtrace_print()` и при панике.
Они могут быть неполными (тогда выводится `CONTINUOS`) и испорчеными (проблема со стеком,
выводится `CORRUPTED`).

Бектрейсы от `PK_ASSERT()` (TODO: сделать) и `pk_log_btrace()` выглядят так (могут передаваться через `netlog`):
```
PikeM backtrace {
 - 0x400d494c:0x3ffb2260
   /home/user/vedruino/src/main.cpp:56
   setup()
 - 0x400d505e:0x3ffb2290
   /home/user/.arduino15/packages/esp32/hardware/esp32/2.0.14/cores/esp32/main.cpp:42
   loopTask(void*)
}
```

Слева от `:` в первой строке каждого фрейма находится адрес инструкции, находящейся до адреса
возврата в этот фрейм. Справа находится указатель на вершину стека.

Из нижних фреймов вызывались функции верхних фреймов.

Если для каких-то адресов не нашлось информации, то вместо файла, строки и функции будет:
```
??:0
??
```

ВАЖНО: в папке `build` должен находиться ELF файл той же версии, что и прошивка на плате.
В противном случае ориентироваться можно будет только по адресам через `make disasm`.

## tools/deesc.py
С помощью него можно убрать ANSI escape коды из текста. Ввод в stdin, вывод в stdout.

