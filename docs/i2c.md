# I2C

## Начало работы

Перед началом работы с i2c, нужно вызвать `pk_i2c_begin()` и передать ему чип мультеплексора или его отсутствие. Выполняет `Wire.begin()`.

```C
typedef enum {
    SW_NONE = 0,  //нет мультиплексора
    SW_PCA9547,   //смотреть на плате
    SW_PW548A,    //смотреть на плате
} pkI2cSwitcher_t;

//инициализация инструментов и Wire.begin()
void pk_i2c_begin(pkI2cSwitcher_t switcher);
```

## Работа с I2C
Т.к используется много ардуиновских библиотек, не готовых для многопоточного использования, требуется блокировка i2c за конкретным потоком. Иначе несколько потоков будут одновременно писать в i2c и всё сломается.
### Блокировка
```C
void pk_i2c_lock();
```
### Разблокировка
```C
void pk_i2c_unlock();
```
Блокироки и разблокировки могут быть вложенными, __но за каждым `pk_i2c_lock()` должен быть `pk_i2c_unlock()`__.

## Переключение (только для мультиплексора)
Мультиплексор нужен для подключения датчиков с одним адресом. Они подключаются в выход мультиплексора __(не в основной!)__. На плате есть линии 3-7, и перед каждым
обращением нужно переключать i2c линию.
```C
void pk_i2c_switch(uint8_t i2c_line);
```
## Cканирование
При обращении к устройству по адресу, оно должно отправить бит подтверждения. Так
проверяются все адреса от 8 до 126. Если есть мультиплексор, то так же проверяются и его линии. Результат пишется в виде логов.
```C
void pk_i2c_scan();
```
Не уверен, что это не испортит работу с устройствами, лучше использовать только для
отладки.